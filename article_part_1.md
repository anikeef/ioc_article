# Python-приложение: расширяем во всех местах. Часть 1

Доброго времени суток! Меня зовут Максим Сахно, я backend-разработчик на языке Python в компании IQtek. Мы занимаемся разработкой продуктов в области IP-телефонии. На своей практике мы столкнулись с такой проблемой, что все клиенты имеют индивидуальные требования к предоставляемому нами ПО и эти требования могут затрагивать произвольные компоненты наших приложений. Таким образом, нам необходимо иметь возможность заменить любой уже существующий или добавить новый компонент и интегрировать его с другими компонентами системы.

Мы хотим поделиться с вами решением этой проблемы, поэтому мы решили опубликовать цикл из трех статей, в которых последовательно рассказыватся о том, как мы пришли к итоговому решению. В первой статье мы приводим первую составляющую решения - локатор служб, рассказываем о некоторых его недостатках и исправляем их. Во второй части вводим концепцию команд инициализации и подробно раскрываем их суть, показываем, как их можно совместно использовать с локатором служб таким образом, чтобы избежать недостатков, связанных с его использованием, а в третьей части показываем, как решить нашу проблему, используя описанные выше инструменты и точки входа Python.

При изучении существующих инструментов мы не нашли такого, которое бы:

* позволяло динамически подгружать компоненты и связывать их друг с другом;

* гарантировало, что при инициализации приложения компоненты получат зависимости нужных типов.

Приятным бонусом было бы отсутствие зависимостей в коде, который не отвечает за инициализацию приложения, от этого инструмента. В данном примере

``` Python
class Service:
    @inject("repository")
    def __init__(repository: Repository) -> None:
        ...
```
компоненту `Service` не нужно знать, каким способом в его конструктор попадет репозиторий. Зависимость от декоратора `inject`, предоставляемого инструментом, явно лишняя. 

Поэтому мы решили создать свой инструмент. В этой статье мы хотим рассказать о том, как и к чему мы в итоге пришли. Для начала давайте рассмотрим такой простой пример, в котором компонент `UserServiceImpl` зависит от компонента `ConsoleLogger`:

``` Python
class UserServiceImpl(UserService):
    __slots__ = ()

    def create(self, email: str) -> User:
        logger = ConsoleLogger("user_service")
        logger.log(f"Creating user with email '{email}'...")
        ...
```

Теперь предположим, что у нас возникла потребность, чтобы логи выводились не в консоль, а в файл. Тогда придется создать класс `FileLogger` и изменить код класса `UserServiceImpl`, а именно в методе `create`  создавать объект класса `FileLogger` вместо `ConsoleLogger`. Разумеется, в достаточно больших проектах любое подобное изменение будет требовать значительных временных затрат.

Проблема состоит в нарушении принципа инверсии зависимостей. Его формулировка звучит так: 

 * Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракции.
 * Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

В нашем примере модуль верхнего уровня `UserServiceImpl`, зависит от модуля нижнего уровня `ConsoleLogger`.

Применение паттерна локатор служб (англ. service locator) позволяет решить обозначенную выше проблему путем создания реестра необходимых зависимостей. В случае использования этого паттерна класс `UserServiceImpl` вместо создания зависимости в виде экземпляра класса `ConsoleLogger` будет запрашивать ее у реестра. Давайте перейдем к реализации данного паттерна на нашем примере.

Для начала выделим абстракцию для логгирования, а именно создадим интерфейс `Logger`:

``` Python
class Logger:
    __slots__ = ()

    def log(self, message: str) -> None:
        raise NotImplementedError()
```

И сделаем так, чтобы `ConsoleLogger` и `FileLogger` реализовывали данный интерфейс. Например, так может выглядеть реализация `ConsoleLogger`:

``` Python
class ConsoleLogger(Logger):
    __slots__ = (
        "__name",
    )

    def __init__(self, name: str) -> None:
        self.__name = name

    def log(self, message: str) -> None:
        sys.stdout.write(f"{self.__name}: {message}\n")
```

Теперь приступим к созданию реестра, который будет хранить зависимости. Одной из самых простых реализаций такого реестра является класс, хранящий объекты по ключам. В качестве ключей могут использоваться, например, строки.

``` Python
class ServiceLocator:
    __slots__ = (
        "__instances",
    )

    def __init__(self) -> None:
        self.__instances: Dict[str, Any] = {}

    def register(self, key: str, instance: Any) -> None:
        self.__instances[key] = instance

    def resolve(self, key: str) -> Any:
        try:
            return self.__instances[key]
        except KeyError:
            raise DependencyResolutionException(key) from None
```

В одном из модулей создадим глобальный зкземпляр, к которому будут обращаться все сущности нашего приложения, которым нужно зарегистрировать или получить зависимость:

``` Python
service_locator = ServiceLocator()
```

Теперь код класса `UserServiceImpl` будет выглядеть следующим образом:

``` Python
class UserServiceImpl(UserService):
    __slots__ = ()

    def create(self, email: str) -> User:
        logger = service_locator.resolve("logger")
        logger.log(f"Creating user with email '{email}'...")
        ...
```

А ниже представлена функция инициализации приложения, которая будет регистрировать в реестр нужные зависимости.

``` Python
def init() -> None:
    service_locator.register("logger", ConsoleLogger("root"))
    service_locator.register("user_service", UserServiceImpl())
```

В случае большого количества зависимостей эта функция может быть разбита на несколько функций меньшего размера, каждая из которых будет заниматься инициализацией своей подсистемы приложения.

Теперь при возникновении потребности выводить логи в файл, а не в консоль, нам необходимо лишь изменить одну строчку в функции конфигурации приложения и изменения вступят в силу для всех компонентов, запрашивающих зависимости через реестр.

Обратите внимание, что теперь благодаря следованию принципу инверсии зависимостей для изменения способа логгирования у класса `UserServiceImpl` у нас нет необходимости изменять его код, что позволяет сократить время, необходимое для внесения изменения в приложение, и избавляет от возможности добавить в этот класс ошибки. Зависимость от абстракции, а не от конкретной реализации, позволяет использовать любую возможную реализацию, не меняя код зависимых компонентов. 

Однако, несмотря на то, что нам удалось таким образом избавиться от жесткой связности между компонентами приложения и сделать его изменение более простым, у текущей реализации данного паттерна есть множество недостатков, но обо всем попорядку. 

Не всегда можно обойтись единственным экземпляром по ключу. В некоторых ситуациях может быть полезно, чтобы при разрешении зависимости каждый раз создавался новый экземпляр объекта или выполнялась какая-то другая логика. Например, в нашем случае нам бы хотелось видеть в логах название того компонента, который осуществил логирование. Для этого нам надо иметь возможность получать экземпляр класса `Logger`, передавая не только ключ, но и имя компонента в качестве параметра. Такую проблему можно решить, если хранить не экземпляры классов, а фабрики для их получения. Этот подход значительно расширяет возможности по получению зависимостей. Используя фабрики, можно реализовать как получение каждый раз единственного экземпляра класса, так и нового, и вообще любую логику по получению зависимостей. Таким образом реализация локатора служб примет следующий вид:

``` Python
class ServiceLocator:
    __slots__ = (
        "__factories",
    )

    def __init__(self) -> None:
        self.__factories: Dict[str, Callable[..., Any]] = {}

    def register(self, key: str, factory: Callable[..., Any]) -> None:
        self.__factories[key] = factory

    def resolve(self, __key: str, /, *args: Any, **kwargs: Any) -> Any:
        try:
            factory = self.__factories[__key]
        except KeyError:
            raise DependencyResolutionException(__key) from None

        return factory(*args, **kwargs)
```

А получение зависимости будет выглядеть уже так:

``` Python
class UserServiceImpl(UserService):
    __slots__ = ()

    def create(self, email: str) -> User:
        logger = service_locator.resolve("logger", "user_service")
        logger.log(f"Creating user with email '{email}'...")
        ...
```

Регистрация в свою очередь будет осуществляться таким образом:

``` Python
def init() -> None:

    def get_console_logger(name: str = "root") -> ConsoleLogger:
        return ConsoleLogger(name)

    service_locator.register("logger", get_console_logger)

    user_service = UserServiceImpl()
    service_locator.register("user_service", lambda: user_service)
```

В данном примере благодаря использованию фабрик удалось реализовать различную логику получения зависимостей: по ключу `user_service` клиенты будут получать каждый раз один и тот же экземпляр класса `UserService`, в то время как по ключу `logger` - каждый раз новый экземпляр класса `Logger`.

При работе с достаточно большим проектом, который уже целиком не помещается в голове разработчика, возникнут следующие проблемы. 

При вызове метода `ServiceLocator.resolve` нам неизвестен тип результата, который мы получим. Действительно какой будет тип у переменной `logger` после выполения следующей строчки кода? 

``` Python 
logger = service_locator.resolve("logger", "user_service")
``` 

Для поддержки уже существующего кода и создания нового очень важно быстро находить ответ на вопрос: какой тип имеет объект, на который ссылается та или иная переменная, какие у него есть методы и какие сигнатуры у этих методов? Эта информация необходима для того, чтобы знать, как взаимодействовать с этим объектом. Конечно, тип результата зависит от ключа. В таком случае придется самому разбираться, что же зарегистрировано по необходимому ключу. Можно, конечно, добавить аннотацию к переменной:

``` Python 
logger: Logger = service_locator.resolve("logger", "user_service")
``` 

Но на самом деле так делать не стоит из-за другой проблемы, а именно из-за отсутствия какой-либо гарантии, что по ключу `"logger"` будет получен объект класса `Logger`. Действительно, кто угодно может зарегистрировать по этому ключу что угодно и не сможет удостовериться в том, что не нарушил уже существующий контракт, связанный с используемым ключом. Под контрактом, связанным с ключом, подразумевается сигнатура, которой должны соответствовать все фабрики, которые могут быть зарегистрированы по этому ключу.

И еще одна проблема. А как узнать, не читая документацию и не заглядывая в код фабрик, какие параметры необходимо передать, чтобы разрешить зависимость по конкретному ключу? При такой реализации, к сожалению, никак. В идеале хотелось бы иметь возможность узнать тип результата и список необходимых параметров сразу. Как этого добиться? Ответ: зафиксировать контракт фабрики и сделать его частью ключа. 

Объявим контракт фабрики, которая предоставляет необходимую зависимость. В нашем случае это логгер:

``` Python
class LoggerFactory:
    __slots__ = ()

    def __call__(self, name: str = "root") -> Logger:
        raise NotImplementedError()
```

Создадим реализацию этой фабрики, причем, если мы нарушим контракт, то с помощью средств статического анализа мы сможем об этом узнать.

``` Python
class ConsoleLoggerFactory(LoggerFactory):
    __slots__ = ()

    def __call__(self, name: str = "root") -> Logger:
        return ConsoleLogger(name)
```

Далее нужно каким-либо способом зафиксировать информацию о типе фабрики в ключе. Используем для этой задачи переменные типа (`TypeVar`) из модуля `typing`. Опишем класс ключа следующим образом:

``` Python
F = TypeVar("F", bound=Callable)


class Key(Generic[F]):
    __slots__ = ()

    def __init__(self, factory_type: Type[F], id: str = "") -> None: ...
```

Теперь реализуем класс локатора служб так, чтобы по ключу средствами статического анализа можно было определить тип фабрики, которую мы получим при попытке получить зависимость:

``` Python
class ServiceLocator:
    __slots__ = (
        "__factories",
    )

    def __init__(self) -> None:
        self.__factories: Dict[Key[Any], Any] = {}

    def set_factory(self, key: Key[F], factory: F) -> None:
        self.__factories[key] = factory

    def get_factory(self, key: Key[F]) -> F:
        try:
            return self.__factories[key]
        except KeyError:
            raise FactoryNotFoundByKeyException(key) from None
```

Чтобы разобраться, как это работает, давайте рассмотрим пример получения зависимости:

``` Python 
class UserServiceImpl(UserService):
    __slots__ = ()

    def create(self, email: str) -> User:
        logger = service_locator.get_factory(Key(LoggerFactory))("user_service")
        logger.log(f"Creating user with email '{email}'...")
        ...
```

Обратите внимание, что выражение `Key(LoggerFactory)` будет иметь тип `Key[LoggerFactory]`, соответственно результат выражения `service_locator.get_factory(Key(LoggerFactory))` будет иметь тип `LoggerFactory`, а далее мы уже вызываем экземпляр класса `LoggerFactory`, благодаря чему средствами статического анализа кода можно установить, что переменная `logger` будет иметь тип `Logger`, и IDE уже сможет давать нам правильные подсказки и не даст совершить глупые ошибки. То же самое относится и к параметрам, передаваемым в фабрику.

Теперь давайте посмотрим на то, как будет выглядеть регистрация фабрик в обновленной реализации локатора служб:

``` Python
def init() -> None:
    service_locator.set_factory(Key(LoggerFactory), ConsoleLoggerFactory())
    service_locator.set_factory(Key(UserServiceFactory), UserServiceFactoryImpl(UserServiceImpl()))
``` 

Снова благодаря тому, что выражение `Key(LoggerFactory)` имеет тип `Key[LoggerFactory]` средствами статического анализа можно вывести то, что второй агрумент должен иметь тип `LoggerFactory`, и не допустить, чтобы по данному ключу была зарегистрирована фабрика другого типа, имеющая другой контракт.

При этом необязательно каждый раз реализовывать интерфейс фабрики вручную, т.к. в большинстве случае можно использовать генераторы реализации фабрик. Например, если нужно, чтобы всегда возвращался один и тот же экземпляр объекта, можно реализовать такой генератор:

``` Python
def generate_singleton_factory(factory_type: Type[F], instance: Any) -> F: ...
```

который по типу фабрики

``` Python
class UserServiceFactory:
    __slots__ = ()

    def __call__(self) -> UserService:
        raise NotImplementedError()
```

сгенерирует реализацию

``` Python
class UserServiceFactoryImpl(UserServiceFactory):
    __slots__ = (
        "__user_service",
    )

    def __init__(self, user_service: UserService) -> None:
        self.__user_service = user_service

    def __call__(self) -> UserService:
        return self.__user_service
``` 

проверяя тип экземпляра и тип результата. Аналогично можно поступить для генерации реализаций фабрик, которые будут вызывать функцию, проверяя сигнатуры фабрики и функции на совместимость.

И тогда регистрация зависимостей будет иметь следующий вид:

``` Python
def init() -> None:

    def get_console_logger(name: str = "root") -> Logger:
        return ConsoleLogger(name)

    logger_factory = generate_function_factory(LoggerFactory, get_console_logger)
    service_locator.set_factory(Key(LoggerFactory), logger_factory)

    user_service_factory = generate_singleton_factory(UserServiceFactory, UserServiceImpl())
    service_locator.register(Key(UserServiceFactory), user_service_factory)
```

Как можно видеть, в таком случае дополнительно нужно только объявлять интерфейсы фабрик.

На этом первая часть статьи подходит к концу. В следующей части мы продолжим улучшать работу с локатором служб. А как вы управляете зависимостями в ваших проектах?
